/**
 * @file http_server.c
 * @brief HTTPS web server implementation
 */

#include "http_server.h"
#include "cloud_provisioning.h"
#include "wifi_manager.h"
#include "time_sync.h"
#include "api_key_manager.h"
#include "esp_log.h"
#include "esp_https_server.h"
#include "esp_timer.h"
#include "esp_wifi.h"
#include "cJSON.h"
#include "nvs_flash.h"
#include "nvs.h"
#include <string.h>

static const char *TAG = "HTTP_SERVER";

static httpd_handle_t s_server = NULL;

// External sensor reading functions from mqtt_telemetry.c
extern float read_temperature(void);
extern float read_humidity(void);
extern float read_soil_moisture(void);
extern float read_light_level(void);
extern float read_battery_level(void);

// Sensor manager functions
#include "sensor_manager.h"
#include "ezo_sensor.h"
#include "ezo_sensor.h"
#include "max17048.h"
#include "mqtt_telemetry.h"  // For MAX_SENSOR_VALUES

// Declare embedded web files (generated by CMake)
extern const uint8_t index_html_start[] asm("_binary_index_html_start");
extern const uint8_t index_html_end[]   asm("_binary_index_html_end");

/**
 * @brief Favicon handler - return 204 No Content to avoid 404 errors
 */
static esp_err_t favicon_handler(httpd_req_t *req)
{
    httpd_resp_set_status(req, "204 No Content");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

/**
 * @brief Root handler - serve dashboard
 */
static esp_err_t root_handler(httpd_req_t *req)
{
    httpd_resp_set_type(req, "text/html");
    httpd_resp_set_hdr(req, "Connection", "keep-alive");
    
    // Calculate size of embedded HTML file
    const size_t html_size = index_html_end - index_html_start;
    
    // Send embedded HTML from flash
    httpd_resp_send(req, (const char *)index_html_start, html_size);
    return ESP_OK;
}

/**
 * @brief API status endpoint - return device status as JSON
 */
static esp_err_t api_status_handler(httpd_req_t *req)
{
    cJSON *root = cJSON_CreateObject();
    
    // Device ID
    char device_id[32];
    cloud_prov_get_device_id(device_id, sizeof(device_id));
    cJSON_AddStringToObject(root, "device_id", device_id);
    
    // WiFi SSID
    char ssid[33];
    char password[64];
    if (wifi_manager_get_stored_credentials(ssid, password) == ESP_OK) {
        cJSON_AddStringToObject(root, "wifi_ssid", ssid);
        memset(password, 0, sizeof(password)); // Clear password
    } else {
        cJSON_AddStringToObject(root, "wifi_ssid", "Not configured");
    }
    
    // IP Address
    if (wifi_manager_is_connected()) {
        // TODO: Get actual IP address from WiFi manager
        cJSON_AddStringToObject(root, "ip_address", "Connected");
    } else {
        cJSON_AddStringToObject(root, "ip_address", "Disconnected");
    }
    
    // WiFi RSSI
    if (wifi_manager_is_connected()) {
        wifi_ap_record_t ap_info;
        if (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK) {
            cJSON_AddNumberToObject(root, "rssi", ap_info.rssi);
        }
    }
    
    // Uptime
    cJSON_AddNumberToObject(root, "uptime", esp_timer_get_time() / 1000000);
    
    // Current time
    char time_str[64];
    if (time_sync_get_time_string(time_str, sizeof(time_str), NULL) == ESP_OK) {
        cJSON_AddStringToObject(root, "current_time", time_str);
    } else {
        cJSON_AddStringToObject(root, "current_time", "Not synced");
    }
    
    // Free heap
    cJSON_AddNumberToObject(root, "free_heap", esp_get_free_heap_size());
    
    // CPU usage (simplified estimate based on idle task)
    // TODO: Implement more accurate CPU monitoring
    cJSON_AddNumberToObject(root, "cpu_usage", 25);
    
    // Get cached sensor data from sensor_manager (non-blocking, no I2C operations)
    sensor_cache_t cache;
    if (sensor_manager_get_cached_data(&cache) == ESP_OK) {
        cJSON *sensors = cJSON_CreateObject();
        
        // Add battery if available
        if (cache.battery_valid) {
            cJSON_AddNumberToObject(root, "battery", cache.battery_percentage);
        }
        
        // Add all cached sensors
        for (uint8_t i = 0; i < cache.sensor_count && i < 8; i++) {
            cached_sensor_t *sensor = &cache.sensors[i];
            if (!sensor->valid) continue;
            
            if (sensor->value_count == 1) {
                // Single value sensor
                cJSON_AddNumberToObject(sensors, sensor->sensor_type, sensor->values[0]);
            } else if (sensor->value_count > 1) {
                // Multi-value sensor
                cJSON *sensor_obj = cJSON_CreateObject();
                
                if (strcmp(sensor->sensor_type, "HUM") == 0) {
                    if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "humidity", sensor->values[0]);
                    if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "air_temp", sensor->values[1]);
                    if (sensor->value_count >= 3) cJSON_AddNumberToObject(sensor_obj, "dew_point", sensor->values[2]);
                } else if (strcmp(sensor->sensor_type, "EC") == 0) {
                    if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "conductivity", sensor->values[0]);
                    if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "tds", sensor->values[1]);
                    if (sensor->value_count >= 3) cJSON_AddNumberToObject(sensor_obj, "salinity", sensor->values[2]);
                } else if (strcmp(sensor->sensor_type, "DO") == 0) {
                    if (sensor->value_count >= 1) cJSON_AddNumberToObject(sensor_obj, "dissolved_oxygen", sensor->values[0]);
                    if (sensor->value_count >= 2) cJSON_AddNumberToObject(sensor_obj, "saturation", sensor->values[1]);
                }
                
                cJSON_AddItemToObject(sensors, sensor->sensor_type, sensor_obj);
            }
        }
        
        cJSON_AddItemToObject(root, "sensors", sensors);
    }
    
    // Send JSON response
    const char *json_str = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, json_str, HTTPD_RESP_USE_STRLEN);
    
    free((void *)json_str);
    cJSON_Delete(root);
    
    return ESP_OK;
}

/**
 * @brief API clear WiFi endpoint
 */
static esp_err_t api_clear_wifi_handler(httpd_req_t *req)
{
    ESP_LOGW(TAG, "WiFi clear requested via dashboard");
    
    // Clear WiFi credentials
    wifi_manager_clear_credentials();
    
    // Send response
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"success\"}", HTTPD_RESP_USE_STRLEN);
    
    // Restart device after a delay
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
    
    return ESP_OK;
}

/**
 * @brief API reboot endpoint
 */
static esp_err_t api_reboot_handler(httpd_req_t *req)
{
    ESP_LOGW(TAG, "Reboot requested via dashboard");
    
    // Send response
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"rebooting\"}", HTTPD_RESP_USE_STRLEN);
    
    // Restart device after a delay
    vTaskDelay(pdMS_TO_TICKS(1000));
    esp_restart();
    
    return ESP_OK;
}

/**
 * @brief API test MQTT endpoint
 */
static esp_err_t api_test_mqtt_handler(httpd_req_t *req)
{
    ESP_LOGI(TAG, "MQTT connection test requested");
    
    // Check if MQTT is connected
    // Note: mqtt_telemetry module doesn't expose connection status yet
    // For now, just return success
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"tested\",\"connected\":true}", HTTPD_RESP_USE_STRLEN);
    
    return ESP_OK;
}

/**
 * @brief API settings endpoint
 */
static esp_err_t api_settings_handler(httpd_req_t *req)
{
    char content[100];
    int ret = httpd_req_recv(req, content, sizeof(content));
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid request");
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    // Parse JSON
    cJSON *root = cJSON_Parse(content);
    if (root == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }
    
    // Get mqtt_interval if present
    cJSON *interval = cJSON_GetObjectItem(root, "mqtt_interval");
    if (interval != NULL && cJSON_IsNumber(interval)) {
        int interval_val = interval->valueint;
        ESP_LOGI(TAG, "Settings update: MQTT interval = %d seconds", interval_val);
        // TODO: Implement actual settings storage and application
        // For now, just acknowledge the setting
    }
    
    cJSON_Delete(root);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_send(req, "{\"status\":\"saved\"}", HTTPD_RESP_USE_STRLEN);
    
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/pause - Pause sensor reading task
 */
static esp_err_t api_sensors_pause_handler(httpd_req_t *req)
{
    sensor_manager_pause_reading();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"paused\"}");
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/resume - Resume sensor reading task
 */
static esp_err_t api_sensors_resume_handler(httpd_req_t *req)
{
    sensor_manager_resume_reading();
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"resumed\"}");
    return ESP_OK;
}

/**
 * @brief GET /api/sensors - Get list of all sensors with their configurations
 */
static esp_err_t api_sensors_list_handler(httpd_req_t *req)
{
    cJSON *root = cJSON_CreateObject();
    cJSON *sensors = cJSON_CreateArray();
    
    // Add battery monitor if available
    if (sensor_manager_has_battery_monitor()) {
        cJSON *battery = cJSON_CreateObject();
        cJSON_AddStringToObject(battery, "type", "MAX17048");
        cJSON_AddNumberToObject(battery, "address", 0x36);
        cJSON_AddStringToObject(battery, "name", "Battery Monitor");
        cJSON_AddStringToObject(battery, "description", "Li+ Battery Fuel Gauge");
        cJSON_AddItemToArray(sensors, battery);
    }
    
    // Add EZO sensors
    uint8_t ezo_count = sensor_manager_get_ezo_count();
    for (uint8_t i = 0; i < ezo_count; i++) {
        ezo_sensor_t *sensor = (ezo_sensor_t*)sensor_manager_get_ezo_sensor(i);
        if (sensor != NULL) {
            cJSON *ezo = cJSON_CreateObject();
            cJSON_AddNumberToObject(ezo, "index", i);
            cJSON_AddNumberToObject(ezo, "address", sensor->config.i2c_address);
            cJSON_AddStringToObject(ezo, "type", sensor->config.type);
            cJSON_AddStringToObject(ezo, "name", sensor->config.name);
            cJSON_AddStringToObject(ezo, "firmware", sensor->config.firmware_version);
            cJSON_AddBoolToObject(ezo, "led", sensor->config.led_control);
            cJSON_AddBoolToObject(ezo, "plock", sensor->config.protocol_lock);
            
            // Add type-specific parameters
            if (strcmp(sensor->config.type, "RTD") == 0) {
                cJSON_AddStringToObject(ezo, "scale", (const char[]){sensor->config.rtd.temperature_scale, '\0'});
            } else if (strcmp(sensor->config.type, "pH") == 0) {
                cJSON_AddBoolToObject(ezo, "extended_scale", sensor->config.ph.extended_scale);
            } else if (strcmp(sensor->config.type, "EC") == 0) {
                cJSON_AddNumberToObject(ezo, "probe_type", sensor->config.ec.probe_type);
                cJSON_AddNumberToObject(ezo, "tds_factor", sensor->config.ec.tds_conversion_factor);
            }
            
            cJSON_AddItemToArray(sensors, ezo);
        }
    }
    
    cJSON_AddItemToObject(root, "sensors", sensors);
    cJSON_AddNumberToObject(root, "count", cJSON_GetArraySize(sensors));
    
    const char *response = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, response);
    
    free((void*)response);
    cJSON_Delete(root);
    
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/rescan - Rescan I2C bus for sensors
 */
static esp_err_t api_sensors_rescan_handler(httpd_req_t *req)
{
    ESP_LOGI(TAG, "Rescanning I2C bus for sensors");
    
    esp_err_t ret = sensor_manager_rescan();
    
    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "status", ret == ESP_OK ? "success" : "error");
    cJSON_AddNumberToObject(root, "battery", sensor_manager_has_battery_monitor() ? 1 : 0);
    cJSON_AddNumberToObject(root, "ezo_count", sensor_manager_get_ezo_count());
    
    const char *response = cJSON_PrintUnformatted(root);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, response);
    
    free((void*)response);
    cJSON_Delete(root);
    
    return ESP_OK;
}

/**
 * @brief POST /api/sensors/config - Update sensor configuration
 * Body: {"address": 99, "led": 1, "name": "MySensor", "scale": "F", etc}
 */
static esp_err_t api_sensors_config_handler(httpd_req_t *req)
{
    char content[512];
    int ret = httpd_req_recv(req, content, sizeof(content) - 1);
    if (ret <= 0) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Empty request");
        return ESP_FAIL;
    }
    content[ret] = '\0';
    
    cJSON *root = cJSON_Parse(content);
    if (root == NULL) {
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Invalid JSON");
        return ESP_FAIL;
    }
    
    cJSON *address_json = cJSON_GetObjectItem(root, "address");
    if (address_json == NULL || !cJSON_IsNumber(address_json)) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Missing address");
        return ESP_FAIL;
    }
    
    uint8_t address = (uint8_t)address_json->valueint;
    
    // Find sensor by address
    ezo_sensor_t *sensor = NULL;
    uint8_t ezo_count = sensor_manager_get_ezo_count();
    for (uint8_t i = 0; i < ezo_count; i++) {
        ezo_sensor_t *s = (ezo_sensor_t*)sensor_manager_get_ezo_sensor(i);
        if (s != NULL && s->config.i2c_address == address) {
            sensor = s;
            break;
        }
    }
    
    if (sensor == NULL) {
        cJSON_Delete(root);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "Sensor not found");
        return ESP_FAIL;
    }
    
    // Update LED
    cJSON *led = cJSON_GetObjectItem(root, "led");
    if (led != NULL && cJSON_IsBool(led)) {
        ezo_sensor_set_led(sensor, cJSON_IsTrue(led));
    }
    
    // Update name
    cJSON *name = cJSON_GetObjectItem(root, "name");
    if (name != NULL && cJSON_IsString(name)) {
        ezo_sensor_set_name(sensor, name->valuestring);
    }
    
    // Update protocol lock
    cJSON *plock = cJSON_GetObjectItem(root, "plock");
    if (plock != NULL && cJSON_IsBool(plock)) {
        ezo_sensor_set_plock(sensor, cJSON_IsTrue(plock));
    }
    
    // Type-specific updates
    if (strcmp(sensor->config.type, "RTD") == 0) {
        cJSON *scale = cJSON_GetObjectItem(root, "scale");
        if (scale != NULL && cJSON_IsString(scale) && strlen(scale->valuestring) > 0) {
            ezo_rtd_set_scale(sensor, scale->valuestring[0]);
        }
    } else if (strcmp(sensor->config.type, "pH") == 0) {
        cJSON *ext_scale = cJSON_GetObjectItem(root, "extended_scale");
        if (ext_scale != NULL && cJSON_IsBool(ext_scale)) {
            ezo_ph_set_extended_scale(sensor, cJSON_IsTrue(ext_scale));
        }
    } else if (strcmp(sensor->config.type, "EC") == 0) {
        cJSON *probe = cJSON_GetObjectItem(root, "probe_type");
        if (probe != NULL && cJSON_IsNumber(probe)) {
            ezo_ec_set_probe_type(sensor, (float)probe->valuedouble);
        }
        
        cJSON *tds = cJSON_GetObjectItem(root, "tds_factor");
        if (tds != NULL && cJSON_IsNumber(tds)) {
            ezo_ec_set_tds_factor(sensor, (float)tds->valuedouble);
        }
    }
    
    cJSON_Delete(root);
    
    httpd_resp_set_type(req, "application/json");
    httpd_resp_sendstr(req, "{\"status\":\"success\"}");
    
    return ESP_OK;
}

// URI handlers
static const httpd_uri_t favicon_uri = {
    .uri = "/favicon.ico",
    .method = HTTP_GET,
    .handler = favicon_handler,
    .user_ctx = NULL
};

static const httpd_uri_t root_uri = {
    .uri = "/",
    .method = HTTP_GET,
    .handler = root_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_status_uri = {
    .uri = "/api/status",
    .method = HTTP_GET,
    .handler = api_status_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_clear_wifi_uri = {
    .uri = "/api/clear-wifi",
    .method = HTTP_POST,
    .handler = api_clear_wifi_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_reboot_uri = {
    .uri = "/api/reboot",
    .method = HTTP_POST,
    .handler = api_reboot_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_test_mqtt_uri = {
    .uri = "/api/test-mqtt",
    .method = HTTP_POST,
    .handler = api_test_mqtt_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_settings_uri = {
    .uri = "/api/settings",
    .method = HTTP_POST,
    .handler = api_settings_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_list_uri = {
    .uri = "/api/sensors",
    .method = HTTP_GET,
    .handler = api_sensors_list_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_rescan_uri = {
    .uri = "/api/sensors/rescan",
    .method = HTTP_POST,
    .handler = api_sensors_rescan_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_config_uri = {
    .uri = "/api/sensors/config",
    .method = HTTP_POST,
    .handler = api_sensors_config_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_pause_uri = {
    .uri = "/api/sensors/pause",
    .method = HTTP_POST,
    .handler = api_sensors_pause_handler,
    .user_ctx = NULL
};

static const httpd_uri_t api_sensors_resume_uri = {
    .uri = "/api/sensors/resume",
    .method = HTTP_POST,
    .handler = api_sensors_resume_handler,
    .user_ctx = NULL
};

/**
 * @brief Handler for CA certificate download
 */
static esp_err_t ca_cert_handler(httpd_req_t *req)
{
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open_from_partition("https", "https", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "CA certificate not found");
        return ESP_FAIL;
    }
    
    size_t ca_cert_len = 0;
    err = nvs_get_str(nvs_handle, "ca_cert", NULL, &ca_cert_len);
    if (err != ESP_OK || ca_cert_len == 0) {
        nvs_close(nvs_handle);
        httpd_resp_send_err(req, HTTPD_404_NOT_FOUND, "CA certificate not available");
        return ESP_FAIL;
    }
    
    char *ca_cert = malloc(ca_cert_len);
    if (ca_cert == NULL) {
        nvs_close(nvs_handle);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Out of memory");
        return ESP_FAIL;
    }
    
    err = nvs_get_str(nvs_handle, "ca_cert", ca_cert, &ca_cert_len);
    nvs_close(nvs_handle);
    
    if (err != ESP_OK) {
        free(ca_cert);
        httpd_resp_send_err(req, HTTPD_500_INTERNAL_SERVER_ERROR, "Failed to read CA certificate");
        return ESP_FAIL;
    }
    
    // Set content type and disposition for download
    httpd_resp_set_type(req, "application/x-pem-file");
    httpd_resp_set_hdr(req, "Content-Disposition", "attachment; filename=\"kannacloud-ca.crt\"");
    
    httpd_resp_send(req, ca_cert, ca_cert_len - 1);
    free(ca_cert);
    
    return ESP_OK;
}

static const httpd_uri_t ca_cert_uri = {
    .uri = "/ca.crt",
    .method = HTTP_GET,
    .handler = ca_cert_handler,
    .user_ctx = NULL
};

esp_err_t http_server_start(void)
{
    if (s_server != NULL) {
        ESP_LOGW(TAG, "HTTPS server already running");
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "Starting HTTPS server...");
    
    // Get certificates from cloud provisioning
    char *certificate = malloc(CLOUD_PROV_MAX_CERT_SIZE);
    char *private_key = malloc(CLOUD_PROV_MAX_KEY_SIZE);
    
    if (certificate == NULL || private_key == NULL) {
        ESP_LOGE(TAG, "Failed to allocate memory for certificates");
        free(certificate);
        free(private_key);
        return ESP_ERR_NO_MEM;
    }
    
    size_t cert_len, key_len;
    esp_err_t err = cloud_prov_get_certificate(certificate, &cert_len);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get certificate: %s", esp_err_to_name(err));
        free(certificate);
        free(private_key);
        return err;
    }
    
    err = cloud_prov_get_private_key(private_key, &key_len);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to get private key: %s", esp_err_to_name(err));
        free(certificate);
        free(private_key);
        return err;
    }
    
    ESP_LOGI(TAG, "Certificate length: %zu bytes", cert_len);
    ESP_LOGI(TAG, "Private key length: %zu bytes", key_len);
    
    // Debug certificate format
    ESP_LOGI(TAG, "Cert first 100 chars: %.100s", certificate);
    if (cert_len > 100) {
        ESP_LOGI(TAG, "Cert last 100 chars: %s", certificate + cert_len - 100);
    }
    
    // Configure HTTPS server
    httpd_ssl_config_t config = HTTPD_SSL_CONFIG_DEFAULT();
    config.httpd.max_uri_handlers = 15;  // Increased for pause/resume endpoints
    config.httpd.stack_size = 8192;  // Reduced stack to save memory
    config.httpd.max_open_sockets = 3;  // Allow multiple connections now that PSRAM is enabled
    config.httpd.lru_purge_enable = true;  // Enable automatic cleanup of old connections
    config.httpd.close_fn = NULL;  // Use default close function
    config.httpd.recv_wait_timeout = 30;  // Increased timeout for SSL handshake (was 10)
    config.httpd.send_wait_timeout = 30;  // Increased timeout for SSL handshake (was 10)
    config.port_insecure = 0;  // Disable insecure port (HTTPS only)
    
    // Set certificates (PEM format from NVS is already null-terminated)
    // mbedTLS needs length + 1 to include the null terminator
    config.servercert = (const uint8_t *)certificate;
    config.servercert_len = cert_len + 1;
    config.prvtkey_pem = (const uint8_t *)private_key;
    config.prvtkey_len = key_len + 1;
    
    // Skip client certificate verification (allows browsers to connect without trusting cert)
    config.session_tickets = false;  // Disable session resumption for testing
    config.use_secure_element = false;  // Not using hardware secure element
    
    // Start server
    err = httpd_ssl_start(&s_server, &config);
    
    // Clean up certificate buffers
    free(certificate);
    free(private_key);
    
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to start HTTPS server: %s", esp_err_to_name(err));
        return err;
    }
    
    // Register URI handlers
    httpd_register_uri_handler(s_server, &favicon_uri);
    httpd_register_uri_handler(s_server, &root_uri);
    httpd_register_uri_handler(s_server, &ca_cert_uri);  // CA certificate download
    httpd_register_uri_handler(s_server, &api_status_uri);
    httpd_register_uri_handler(s_server, &api_clear_wifi_uri);
    httpd_register_uri_handler(s_server, &api_reboot_uri);
    httpd_register_uri_handler(s_server, &api_test_mqtt_uri);
    httpd_register_uri_handler(s_server, &api_settings_uri);
    httpd_register_uri_handler(s_server, &api_sensors_list_uri);
    httpd_register_uri_handler(s_server, &api_sensors_rescan_uri);
    httpd_register_uri_handler(s_server, &api_sensors_config_uri);
    httpd_register_uri_handler(s_server, &api_sensors_pause_uri);
    httpd_register_uri_handler(s_server, &api_sensors_resume_uri);
    
    ESP_LOGI(TAG, "âœ“ HTTPS server started successfully");
    ESP_LOGI(TAG, "Dashboard accessible at: https://kc.local");
    ESP_LOGI(TAG, "Registered 11 API endpoints (includes pause/resume)");
    
    return ESP_OK;
}

esp_err_t http_server_stop(void)
{
    if (s_server == NULL) {
        return ESP_OK;
    }
    
    ESP_LOGI(TAG, "Stopping HTTPS server");
    httpd_ssl_stop(s_server);
    s_server = NULL;
    
    return ESP_OK;
}

bool http_server_is_running(void)
{
    return (s_server != NULL);
}
